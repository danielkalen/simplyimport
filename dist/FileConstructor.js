// Generated by CoffeeScript 1.10.0
var File, chalk, consoleLabels, fs, helpers, md5, path, regEx;

fs = require('fs');

md5 = require('md5');

path = require('path');

chalk = require('chalk');

regEx = require('./regex');

helpers = require('./helpers');

consoleLabels = require('./consoleLabels');


/**
 * The object created for each file path the program needs to open/import/read.
 * @param {String} input               	File's path or file's contents
 * @param {Object} state	          	(optional) initial state map to indicate if 'isStream', 'isCoffee', and 'context'
 * @param {Object} importHistory	 	(optional) the import history collected so far since the main faile import
 */

File = function(input, state, importHistory) {
  var key, ref, value;
  if (state == null) {
    state = {};
  }
  this.importHistory = importHistory != null ? importHistory : {};
  for (key in state) {
    value = state[key];
    this[key] = value;
  }
  this.trackedImportHistory = {};
  this.context = process.cwd();
  if (this.isCoffee == null) {
    this.isCoffee = false;
  }
  if (this.isStream == null) {
    this.isStream = false;
  }
  if (this.isStream) {
    this.content = input;
  } else {
    this.filePath = path.normalize(input);
    this.fileExt = (ref = this.filePath.match(regEx.fileExt)) != null ? ref[1].toLowerCase() : void 0;
    this.context = helpers.getNormalizedDirname(this.filePath);
    this.isCoffee = this.checkIfIsCoffee();
    this.content = this.getContents();
    if (!this.content && !options.silent) {
      console.warn(consoleLabels.warn + " Failed to import nonexistent file: " + (chalk.dim(helpers.simplifyPath(this.filePath))));
    }
  }
  this.collectTrackedImports();
  this.hash = md5(this.content);
  return this;
};

File.prototype.getContents = function() {
  var content, error, error1, pathsToTry, succeededPath;
  if (this.fileExt) {
    try {
      return fs.readFileSync(this.filePath).toString();
    } catch (error) {
      return '';
    }
  } else if (this.isCoffee) {
    pathsToTry = [this.filePath + ".coffee", this.filePath + ".js"];
  } else {
    pathsToTry = [this.filePath + ".js", this.filePath + ".coffee"];
  }
  content = '';
  try {
    try {
      content = fs.readFileSync(pathsToTry[0]).toString();
      succeededPath = 0;
    } catch (error1) {
      content = fs.readFileSync(pathsToTry[1]).toString();
      succeededPath = 1;
    }
  } catch (undefined) {}
  if (succeededPath != null) {
    this.isCoffee = pathsToTry[succeededPath].includes('.coffee');
  }
  return content;
};

File.prototype.collectTrackedImports = function() {
  if (this.content) {
    return this.content.replace(regEx.trackedImport, (function(_this) {
      return function(entire, hash) {
        return _this.importHistory[hash] = _this.trackedImportHistory[hash] = _this.filePath || 'stdin';
      };
    })(this));
  }
};

File.prototype.checkIfIsCoffee = function() {
  if (this.fileExt) {
    return this.fileExt === 'coffee';
  } else {
    return this.isCoffee;
  }
};

module.exports = File;
