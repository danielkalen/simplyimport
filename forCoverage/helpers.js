// Generated by CoffeeScript 1.10.0
var Promise, acorn, babel, chalk, consoleLabels, coreModuleShims, coreModulesUnsupported, dirListingCache, escodegen, fs, helpers, path, regEx, resolveModule, stackTraceFilter;

Promise = require('bluebird');

resolveModule = Promise.promisify(require('browser-resolve'));

fs = Promise.promisifyAll(require('fs-extra'));

path = require('path');

chalk = require('chalk');

acorn = require('acorn');

escodegen = require('escodegen');

babel = require('babel-core');

regEx = require('./regex');

consoleLabels = require('./consoleLabels');

stackTraceFilter = require('stack-filter');

stackTraceFilter.filters.push('bluebird');

coreModulesUnsupported = ['child_process', 'cluster', 'dgram', 'dns', 'fs', 'module', 'net', 'readline', 'repl', 'tls'];

coreModuleShims = {
  '': path.resolve(__dirname, '..', 'node_modules', ''),
  'assert': path.resolve(__dirname, '..', 'node_modules', 'assert', 'assert.js'),
  'zlib': path.resolve(__dirname, '..', 'node_modules', '@danielkalen', 'browserify-zlib', 'src', 'index.js'),
  'buffer': path.resolve(__dirname, '..', 'node_modules', 'buffer', 'index.js'),
  'console': path.resolve(__dirname, '..', 'node_modules', 'console-browserify', 'index.js'),
  'constants': path.resolve(__dirname, '..', 'node_modules', 'constants-browserify', 'constants.json'),
  'crypto': path.resolve(__dirname, '..', 'node_modules', 'crypto-browserify', 'index.js'),
  'domain': path.resolve(__dirname, '..', 'node_modules', 'domain-browser', 'index.js'),
  'events': path.resolve(__dirname, '..', 'node_modules', 'events', 'events.js'),
  'https': path.resolve(__dirname, '..', 'node_modules', 'https-browserify', 'index.js'),
  'os': path.resolve(__dirname, '..', 'node_modules', 'os-browserify', 'browser.js'),
  'path': path.resolve(__dirname, '..', 'node_modules', 'path-browserify', 'index.js'),
  'process': path.resolve(__dirname, '..', 'node_modules', 'process', 'browser.js'),
  'punycode': path.resolve(__dirname, '..', 'node_modules', 'punycode', 'punycode.js'),
  'querystring': path.resolve(__dirname, '..', 'node_modules', 'querystring-es3', 'index.js'),
  'http': path.resolve(__dirname, '..', 'node_modules', 'stream-http', 'index.js'),
  'string_decoder': path.resolve(__dirname, '..', 'node_modules', 'string_decoder', 'index.js'),
  'stream': path.resolve(__dirname, '..', 'node_modules', 'stream-browserify', 'index.js'),
  'timers': path.resolve(__dirname, '..', 'node_modules', 'timers-browserify', 'main.js'),
  'tty': path.resolve(__dirname, '..', 'node_modules', 'tty-browserify', 'index.js'),
  'url': path.resolve(__dirname, '..', 'node_modules', 'url', 'url.js'),
  'util': path.resolve(__dirname, '..', 'node_modules', 'util', 'util.js'),
  'vm': path.resolve(__dirname, '..', 'node_modules', 'vm-browserify', 'index.js')
};

escodegen.ReturnStatement = function(argument) {
  return {
    type: 'ReturnStatement',
    argument: argument
  };
};

helpers = {
  getNormalizedDirname: function(inputPath) {
    return path.normalize(path.dirname(path.resolve(inputPath)));
  },
  simplifyPath: function(inputPath) {
    return inputPath.replace(process.cwd() + '/', '');
  },
  testForComments: function(line, isCoffee) {
    var hasDocBlockComment, hasSingleLineComment;
    hasSingleLineComment = line.includes(isCoffee ? '#' : '//');
    hasDocBlockComment = /^(?:\s+\*|\*)/.test(line);
    return hasSingleLineComment || hasDocBlockComment;
  },
  testForOuterString: function(line) {
    var i, importSyntax, insideQuotes, len, quote;
    insideQuotes = line.match(regEx.stringContents);
    if (insideQuotes) {
      importSyntax = (function() {
        var word;
        word = regEx["import"].test(line) ? 'import' : 'require';
        return new RegExp("\\b" + word + "\\b");
      })();
      for (i = 0, len = insideQuotes.length; i < len; i++) {
        quote = insideQuotes[i];
        if (importSyntax.test(quote)) {
          return true;
        }
      }
    }
    return false;
  },
  testConditions: function(allowedConditions, conditionsString) {
    var condition, conditions, i, len;
    if (allowedConditions.length === 1 && allowedConditions[0] === '*') {
      return true;
    }
    conditions = conditionsString.split(/,\s?/).filter(function(nonEmpty) {
      return nonEmpty;
    });
    for (i = 0, len = conditions.length; i < len; i++) {
      condition = conditions[i];
      if (!allowedConditions.includes(condition)) {
        return false;
      }
    }
    return true;
  },
  testIfIsExportMap: function(string) {
    var objContents, ref;
    if (objContents = (ref = string.match(/^\{(.+?)\};?$/)) != null ? ref[1] : void 0) {
      return !objContents.includes(':');
    }
    return false;
  },
  commentOut: function(line, isCoffee) {
    var comment;
    comment = isCoffee ? '#' : '//';
    return line.replace(/import/, function(entire) {
      return comment + " " + entire;
    });
  },
  getDirListing: function(dirPath, fromCache) {
    if ((dirListingCache[dirPath] != null) && fromCache) {
      return Promise.resolve(dirListingCache[dirPath]);
    } else {
      return fs.readdirAsync(dirPath).then(function(listing) {
        return dirListingCache[dirPath] = listing;
      });
    }
  },
  parseMembersString: function(membersString) {
    var members, output;
    if (!membersString) {
      return {};
    } else {
      output = {};
      membersString = membersString.replace(/^\{\s*/, '').replace(/\s*\}$/, '');
      if (membersString.startsWith('*')) {
        output['!*!'] = membersString.split(/\s+as\s+/)[1];
      } else {
        members = membersString.split(/,\s*/);
        members.forEach(function(memberSignature) {
          var member;
          member = memberSignature.split(/\s+as\s+/);
          return output[member[0]] = member[1] || member[0];
        });
      }
      return output;
    }
  },
  normalizeExportMap: function(mappingString) {
    var output;
    output = mappingString.replace(/^\{\s*/, '').replace(/\s*\}$/, '').split(/,\s*/).map(function(memberSignature) {
      var member;
      member = memberSignature.split(/\s+as\s+/);
      return "'" + (member[1] || member[0]) + "':" + member[0];
    }).join(', ');
    return "{" + output + "}";
  },
  genUniqueVar: function() {
    return "_sim_" + (Math.floor((1 + Math.random()) * 100000).toString(16));
  },
  addSpacingToString: function(string, spacing) {
    return string.split('\n').map(function(line) {
      return spacing + line;
    }).join('\n');
  },
  escapeBackticks: function(content) {
    return content.replace(regEx.preEscapedBackTicks, '`').replace(regEx.backTicks, '\\`');
  },
  formatJsContentForCoffee: function(jsContent) {
    return jsContent.replace(regEx.escapedNewLine, '').replace(regEx.fileContent, function(entire, spacing, content) {
      return spacing + "`" + (helpers.escapeBackticks(content)) + "`";
    });
  },
  wrapInClosure: function(content, isCoffee, asFunc) {
    var fnSignature, fnSignatureEnd, fnSignatureStart;
    if (isCoffee) {
      fnSignature = asFunc ? '()->' : 'do ()=>';
      return fnSignature + "\n" + (this.addSpacingToString(content, '\t')) + "\n";
    } else {
      fnSignatureStart = asFunc ? 'function(){' : '(function(){';
      fnSignatureEnd = asFunc ? '}' : '}).call(this)';
      return fnSignatureStart + "\n" + content + "\n" + fnSignatureEnd;
    }
  },
  wrapInExportsClosure: function(content, isCoffee, asFunc) {
    var fnSignature, fnSignatureEnd, fnSignatureStart;
    if (isCoffee) {
      fnSignature = asFunc ? '(exports)->' : "do (exports={})=>";
      return fnSignature + "\n\tmodule = {exports}\n" + (this.addSpacingToString(content, '\t')) + "\n\treturn module.exports";
    } else {
      fnSignatureStart = asFunc ? 'function(exports){' : '(function(exports){';
      fnSignatureEnd = asFunc ? '}' : '}).call(this, {})';
      return fnSignatureStart + "\n\tvar module = {exports:exports};\n" + content + "\n\treturn module.exports;\n" + fnSignatureEnd;
    }
  },
  wrapInLoaderClosure: function(assignments, spacing, isCoffee) {
    var loader;
    if (isCoffee) {
      assignments = this.addSpacingToString(assignments.join('\n'), spacing);
      return loader = "_s$m=(m,c,l,_s$m)->\n" + spacing + "_s$m=(r)->if l[r] then c[r] else `(l[r]=1,c[r]={},c[r]=m[r](c[r]))`\n" + assignments + "\n" + spacing + "_s$m\n_s$m=_s$m({},{},{})";
    } else {
      assignments = assignments.join('\n');
      return loader = "var _s$m=function(m,c,l,_s$m){_s$m=function(r){return l[r] ? c[r]: (l[r]=1,c[r]={},c[r]=m[r](c[r]));};\n" + assignments + "\nreturn _s$m;};\ _s$m=_s$m({},{},{})";
    }
  },
  modToReturnLastStatement: function(content, filePath) {
    var AST, MAX_CHARS, OFFSET, error, lastDeclarationID, lastStatement, preview, syntaxErr;
    switch (false) {
      case !!filePath.endsWith('js'):
        if (filePath.endsWith('json')) {
          content = "return " + content;
        }
        return content;
      default:
        try {
          AST = acorn.parse(content, {
            allowReserved: true,
            allowReturnOutsideFunction: true
          });
          lastStatement = AST.body[AST.body.length - 1];
          switch (false) {
            case !(AST.body.length === 1 && lastStatement.type === 'ExpressionStatement'):
              return 'ExpressionStatement';
            default:
              switch (lastStatement.type) {
                case 'ReturnStatement':
                  return content;
                case 'ExpressionStatement':
                  AST.body[AST.body.length - 1] = escodegen.ReturnStatement(lastStatement.expression);
                  return escodegen.generate(AST);
                case 'VariableDeclaration':
                  lastDeclarationID = lastStatement.declarations.slice(-1)[0].id;
                  AST.body.push(escodegen.ReturnStatement(lastDeclarationID));
                  return escodegen.generate(AST);
                default:
                  return content;
              }
          }
        } catch (error) {
          syntaxErr = error;
          OFFSET = 20;

          /* istanbul ignore next */
          if (content.length < OFFSET * 2 || syntaxErr.pos - OFFSET < 0) {
            OFFSET = 0;
          }
          MAX_CHARS = 100;
          preview = syntaxErr.preview = content.substr(syntaxErr.pos - OFFSET, MAX_CHARS);
          preview = preview.substr(0, OFFSET) + chalk.red.bold(preview[OFFSET]) + preview.substr(OFFSET + 1);
          preview = '\n' + chalk.dim(preview);
          syntaxErr.targetFile = filePath;
          syntaxErr.stack = stackTraceFilter.filter(syntaxErr.stack).join('\n');
          console.error(consoleLabels.error, syntaxErr, preview);
          return content;
        }
    }
  },
  transpileES6toES5: function(code) {
    var transpiled;
    transpiled = babel.transform(code, {
      presets: 'latest',
      ast: false
    }).code;
    if (!regEx.useStrict.test(code)) {
      transpiled = transpiled.replace(regEx.useStrict, '');
    }
    return transpiled;
  },
  resolveModulePath: function(moduleName, basedir) {
    var moduleLoad;
    moduleLoad = moduleName.startsWith('/') || moduleName.includes('./') ? Promise.resolve() : resolveModule(moduleName, {
      basedir: basedir,
      modules: coreModuleShims
    });
    return moduleLoad.then((function(_this) {
      return function(modulePath) {
        return Promise.resolve(modulePath);
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        return Promise.resolve();
      };
    })(this)).then((function(_this) {
      return function(modulePath) {
        return Promise.resolve(modulePath);
      };
    })(this));
  },
  isCoreModule: function(moduleName) {
    return coreModulesUnsupported.includes(moduleName);
  }
};

dirListingCache = {};

module.exports = helpers;
