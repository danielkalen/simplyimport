// Generated by CoffeeScript 1.10.0
var File, PATH, Promise, chalk, coffeeCompiler, consoleLabels, fs, helpers, md5, regEx, replaceAsync, uglifier;

Promise = require('bluebird');

fs = Promise.promisifyAll(require('fs-extra'));

replaceAsync = require('string-replace-async');

md5 = require('md5');

PATH = require('path');

chalk = require('chalk');

coffeeCompiler = require('coffee-script');

uglifier = require('uglify-js');

regEx = require('./regex');

helpers = require('./helpers');

consoleLabels = require('./consoleLabels');


/**
 * The object created for each file path the program needs to open/import/read.
 * @param {String} input               	File's path or file's contents
 * @param {Object} state	          	(optional) initial state map to indicate if 'isStream', 'isCoffee', and 'context'
 * @param {Object} importHistory	 	(optional) the import history collected so far since the main faile import
 */

File = function(input, options, importRefs1, arg) {
  var ref;
  this.options = options;
  this.importRefs = importRefs1;
  ref = arg != null ? arg : {}, this.isMain = ref.isMain, this.isCoffee = ref.isCoffee, this.context = ref.context;
  this.input = input;
  this.importedCount = 0;
  this.imports = [];
  this.badImports = [];
  this.importMemberRefs = [];
  this.lineRefs = [];
  this.orderRefs = [];
  this.contentReference = this.getID();
  this.cacheRef = this.isMain ? '*MAIN*' : input;
  if (this.isMain) {
    this.importRefs.main = this;
  }
  return File.instanceCache[this.cacheRef] || this;
};

File.prototype.getID = function() {
  if (this.isMain) {
    return this.currentID = 0;
  } else {
    return this.importRefs.main.currentID += 1;
  }
};

File.prototype.process = function() {
  if (this.processPromise) {
    return this.processPromise;
  } else {
    return this.processPromise = Promise.bind(this).then(this.getFilePath).then(this.getSimpleFilePath).then(this.resolveContext).then(this.checkIfIsCoffee).then(this.getContents).then(this.checkIfIsThirdPartyBundle).then((function(_this) {
      return function() {
        var base, name;
        if (!_this.isMain) {
          if (File.instanceCache[_this.hash] && !File.instanceCache[_this.cacheRef]) {
            File.instanceCache[_this.cacheRef] = File.instanceCache[_this.hash];
          } else {
            File.instanceCache[_this.hash] = _this;
          }
        }
        return (base = File.instanceCache)[name = _this.cacheRef] || (base[name] = _this);
      };
    })(this));
  }
};

File.prototype.getContents = function() {
  if (this.isMain) {
    this.contentLines = this.input.split('\n');
    this.hash = md5(this.input);
    return this.content = this.input;
  } else {
    return fs.readFileAsync(this.filePath, {
      encoding: 'utf8'
    }).then((function(_this) {
      return function(content) {
        _this.content = content;
        _this.hash = md5(content);
        _this.contentLines = content.split('\n');
        return content;
      };
    })(this));
  }
};

File.prototype.getFilePath = function() {
  var inputFileName, parentDir;
  if (this.isMain) {
    return this.context;
  } else if (PATH.extname(this.input)) {
    return this.filePath = this.input;
  } else {
    inputFileName = PATH.basename(this.input);
    parentDir = PATH.dirname(this.input);
    return helpers.getDirListing(parentDir, this.options.dirCache).then((function(_this) {
      return function(parentDirListing) {
        var exactMatch, fileMatch, inputPathMatches, resolvedPath;
        inputPathMatches = parentDirListing.filter(function(targetPath) {
          return targetPath.includes(inputFileName);
        });
        if (!inputPathMatches.length) {
          return _this.filePath = _this.input;
        } else {
          exactMatch = inputPathMatches.find(function(targetPath) {
            return targetPath === inputFileName;
          });
          fileMatch = inputPathMatches.find(function(targetPath) {
            var fileNameSplit;
            fileNameSplit = targetPath.replace(inputFileName, '').split('.');
            return !fileNameSplit[0] && fileNameSplit.length === 2;
          });
          if (fileMatch) {
            return _this.filePath = PATH.join(parentDir, fileMatch);
          } else {
            resolvedPath = PATH.join(parentDir, inputFileName);
            return fs.statAsync(resolvedPath).then(function(pathStats) {
              if (!pathStats.isDirectory()) {
                return _this.filePath = resolvedPath;
              } else {
                return helpers.getDirListing(resolvedPath, _this.options.dirCache).then(function(targetDirListing) {
                  var indexFile;
                  indexFile = targetDirListing.find(function(file) {
                    return file.includes('index');
                  });
                  if (indexFile) {
                    return _this.filePath = PATH.join(parentDir, inputFileName, indexFile);
                  } else {
                    return _this.filePath = PATH.join(parentDir, inputFileName, 'index.js');
                  }
                });
              }
            });
          }
        }
      };
    })(this));
  }
};

File.prototype.getSimpleFilePath = function() {
  if (this.filePath) {
    return this.filePathSimple = helpers.simplifyPath(this.filePath);
  } else {
    return this.filePathSimple = '*MAIN*';
  }
};

File.prototype.resolveContext = function() {
  if (this.isMain) {
    return this.context;
  } else {
    return this.context = helpers.getNormalizedDirname(this.filePath);
  }
};

File.prototype.checkIfIsCoffee = function() {
  return this.isCoffee = this.isMain ? this.isCoffee : PATH.extname(this.filePath).toLowerCase().slice(1) === 'coffee';
};

File.prototype.checkIfIsThirdPartyBundle = function() {

  /* istanbul ignore next */
  return this.isThirdPartyBundle = this.content.includes('.code="MODULE_NOT_FOUND"') || this.content.includes('__webpack_require__') || this.content.includes('System.register') || this.content.includes("typeof module ===") || this.content.includes("typeof module !==") || this.content.includes("typeof define === 'function'") || this.content.includes("typeof define === \"function\"") || this.content.includes("typeof require === 'function'") || this.content.includes("typeof require === \"function\"") || this.content.includes("' has not been defined'");
};

File.prototype.checkIfImportsFile = function(targetFile) {
  var checkArray, importRefs, iteratedArrays;
  iteratedArrays = [this.imports];
  importRefs = this.importRefs;
  checkArray = (function(_this) {
    return function(importsArray) {
      return importsArray.includes(targetFile.hash) || importsArray.find(function(importHash) {
        var currentFile;
        currentFile = importRefs[importHash];
        if (iteratedArrays.includes(currentFile.imports)) {
          return false;
        } else {
          iteratedArrays.push(currentFile.imports);
          return checkArray(currentFile.imports);
        }
      });
    };
  })(this);
  return checkArray(this.imports);
};

File.prototype.addLineRef = function(entireLine, targetRef, offset) {
  var existingRef, lineIndex;
  if (offset == null) {
    offset = 0;
  }
  lineIndex = this.contentLines.indexOf(entireLine, offset);
  existingRef = this.lineRefs.findIndex(function(existingLineRef) {
    return existingLineRef === lineIndex;
  });
  if (existingRef >= 0) {
    return this.addLineRef(entireLine, targetRef, lineIndex + 1);
  } else {
    return this.lineRefs[targetRef] = lineIndex;
  }
};

File.prototype.processImport = function(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members) {
  var orderRefIndex, origChildPath;
  if (conditions == null) {
    conditions = '';
  }
  if (defaultMember == null) {
    defaultMember = '';
  }
  if (members == null) {
    members = '';
  }
  entireLine = entireLine.replace(/^\n+/, '');
  orderRefIndex = this.orderRefs.push(entireLine) - 1;
  childPath = origChildPath = childPath.replace(/['"]/g, '').replace(/[;\s]+$/, '');
  return helpers.resolveModulePath(childPath, this.context).then((function(_this) {
    return function(modulePath) {
      var childFile;
      childPath = modulePath || PATH.resolve(_this.context, childPath);
      if (helpers.testForComments(entireLine, _this.isCoffee) || helpers.testForOuterString(entireLine) || helpers.isCoreModule(origChildPath)) {
        return Promise.resolve();
      } else if (!helpers.testConditions(_this.options.conditions, conditions)) {
        _this.badImports.push(childPath);
        _this.addLineRef(entireLine, 'bad_' + (_this.badImports.length - 1));
        return Promise.resolve();
      } else {
        childFile = new File(childPath, _this.options, _this.importRefs);
        return childFile.process().then(function(childFile) {
          childFile.importedCount++;
          _this.importRefs[childFile.hash] = childFile;
          _this.imports[orderRefIndex] = childFile.hash;
          _this.orderRefs[orderRefIndex] = childFile.hash;
          _this.addLineRef(entireLine, orderRefIndex);
          if (defaultMember || members) {
            _this.importMemberRefs[orderRefIndex] = {
              "default": defaultMember,
              members: helpers.parseMembersString(members)
            };
            childFile.hasUsefulExports = true;
          }
          if (priorContent) {
            childFile.requiresReturnedClosure = /\S/.test(priorContent);
          }
          return Promise.resolve();
        })["catch"](function(err) {
          var selfReference;
          if (_this.options.recursive) {
            selfReference = _this.filePathSimple + ':' + _this.contentLines.indexOf(entireLine);
            console.error(consoleLabels.error + " File/module doesn't exist " + childFile.filePathSimple + " " + (chalk.dim(selfReference)));
            return Promise.reject(err);
          }
        });
      }
    };
  })(this));
};

File.prototype.collectImports = function() {
  if (this.collectedImports) {
    return this.collectedImports;
  } else {
    this.collectedImports = Promise.resolve().then((function(_this) {
      return function() {
        return replaceAsync.seq(_this.content, regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath) {
          return _this.processImport(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members);
        });
      };
    })(this)).then((function(_this) {
      return function() {
        if (!_this.isThirdPartyBundle) {
          return replaceAsync.seq(_this.content, regEx.commonJS["import"], function(entireLine, priorContent, bracketOrSpace, childPath, trailingContent) {
            if (regEx.singleBracketEnd.test(trailingContent)) {
              return Promise.resolve();
            } else {
              return _this.processImport(childPath, entireLine, priorContent);
            }
          });
        }
      };
    })(this));
    return this.collectedImports.then((function(_this) {
      return function() {
        if (regEx["export"].test(_this.content) || regEx.commonJS["export"].test(_this.content) || regEx.exportsVar.test(_this.content)) {
          _this.hasExports = true;
          if (!_this.isThirdPartyBundle) {
            return _this.normalizeExports();
          }
        }
      };
    })(this)).then((function(_this) {
      return function() {
        if (_this.options.recursive) {
          return Promise.all(_this.imports.map(function(childFileHash) {
            return _this.importRefs[childFileHash];
          }).filter(function(file) {
            return !file.checkIfImportsFile(_this);
          }).map(function(file) {
            return file.collectImports();
          }));
        }
      };
    })(this));
  }
};

File.prototype.normalizeExports = function() {
  this.content.replace(regEx.commonJS["export"], (function(_this) {
    return function(entireLine, priorContent, operator, trailingContent) {
      var lineIndex;
      if (operator === '=') {
        operator = " " + operator;
      }
      lineIndex = _this.contentLines.indexOf(entireLine);
      return _this.contentLines[lineIndex] = priorContent + "module.exports" + operator + trailingContent;
    };
  })(this));
  return this.content.replace(regEx["export"], (function(_this) {
    return function(entireLine, exportMap, exportType, label, trailingContent) {
      var labelName, lineIndex, value;
      lineIndex = _this.contentLines.indexOf(entireLine);
      switch (false) {
        case !exportMap:
          return _this.contentLines[lineIndex] = "module.exports = " + (helpers.normalizeExportMap(exportMap)) + trailingContent;
        case exportType !== 'default':
          switch (false) {
            case !helpers.testIfIsExportMap(label + trailingContent):
              exportMap = label + trailingContent.replace(/;$/, '');
              return _this.contentLines[lineIndex] = "module.exports['*default*'] = " + (helpers.normalizeExportMap(exportMap));
            default:
              return _this.contentLines[lineIndex] = "module.exports['*default*'] = " + label + trailingContent;
          }
        case !(exportType != null ? exportType.includes('function') : void 0):
          labelName = label.replace(/\(.*?\).*$/, '');

          /* istanbul ignore next */
          value = trailingContent.includes('=>') ? "" + label + trailingContent : exportType + " " + label + trailingContent;
          return _this.contentLines[lineIndex] = "module.exports['" + labelName + "'] = " + value;
        case exportType !== 'class':
          return _this.contentLines[lineIndex] = "module.exports['" + label + "'] = " + exportType + " " + label + trailingContent;
        case !exportType:
          return _this.contentLines[lineIndex] = exportType + " " + label + " = module.exports['" + label + "'] = " + (trailingContent.replace(/^\s*\=\s*/, ''));
        case !(!exportType && !exportMap):
          label = trailingContent.match(/^\S+/)[0];
          return _this.contentLines[lineIndex] = "module.exports['" + label + "'] = " + trailingContent;
      }
    };
  })(this));
};

File.prototype.replaceImports = function(childImports) {
  this.imports.forEach((function(_this) {
    return function(childHash, importIndex) {
      var childContent, childFile, replaceLine, targetLine;
      childFile = _this.importRefs[childHash];
      childContent = childFile.compiledContent;
      targetLine = _this.lineRefs[importIndex];
      replaceLine = function(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members) {
        var alias, exportedName, importData, key, ref, varPrefix;
        if (childFile.importedCount > 1) {
          childContent = "_s$m(" + childFile.contentReference + ")";
        } else {
          if (priorContent && priorContent.replace(/\s/g, '') === '') {
            spacing = priorContent + spacing;
            priorContent = '';
          }
          if (spacing && !priorContent) {
            childContent = helpers.addSpacingToString(childContent, spacing);
          }
          switch (false) {
            case !(_this.isCoffee && !childFile.isCoffee):
              childContent = helpers.formatJsContentForCoffee(childContent);
              break;
            case !(childFile.isCoffee && !_this.isCoffee):
              if (_this.options.compileCoffeeChildren) {
                childContent = coffeeCompiler.compile(childContent, {
                  'bare': true
                });
              } else {
                throw new Error(consoleLabels.error + " You're attempting to import a Coffee file into a JS file (which will provide a broken file), rerun this import with -C or --compile-coffee-children");
              }
          }
          if (_this.options.uglify) {
            childContent = uglifier.minify(childContent, {
              'fromString': true,
              'compressor': {
                'keep_fargs': true,
                'unused': false
              }
            }).code;
          }
        }
        if (trailingContent.startsWith(')')) {
          if (priorContent) {
            spacing += '(';
          } else {
            priorContent = '(';
            spacing = '';
          }
        }
        if (childFile.hasUsefulExports && (importData = _this.importMemberRefs[importIndex])) {
          _this.requiresClosure = true;
          exportedName = helpers.genUniqueVar();
          varPrefix = _this.isCoffee ? '' : 'var ';
          childContent = "" + varPrefix + exportedName + " = " + childContent + ";\n";
          if (importData["default"]) {
            childContent += "" + varPrefix + importData["default"] + " = " + exportedName + "['*default*'];\n";
          }
          ref = importData.members;
          for (key in ref) {
            alias = ref[key];
            if (key === '!*!') {
              childContent += "" + varPrefix + alias + " = " + exportedName + ";\n";
            } else {
              childContent += "" + varPrefix + alias + " = " + exportedName + "['" + key + "'];\n";
            }
          }
        }
        if (priorContent && childContent) {
          childContent = priorContent + spacing + childContent;
        }
        return childContent + trailingContent;
      };
      if (regEx["import"].test(_this.contentLines[targetLine])) {
        return _this.contentLines[targetLine] = _this.contentLines[targetLine].replace(regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath, trailingContent) {
          return replaceLine(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members);
        });
      } else {
        return _this.contentLines[targetLine] = _this.contentLines[targetLine].replace(regEx.commonJS["import"], function(entireLine, priorContent, bracketOrSpace, childPath, trailingContent) {
          return replaceLine(childPath, entireLine, priorContent, trailingContent, '');
        });
      }
    };
  })(this));
};

File.prototype.replaceBadImports = function() {
  var badImport, i, index, len, ref, results, targetLine;
  ref = this.badImports;
  results = [];
  for (index = i = 0, len = ref.length; i < len; index = ++i) {
    badImport = ref[index];
    targetLine = this.lineRefs['bad_' + index];
    if (this.options.preserve) {
      results.push(this.contentLines[targetLine] = helpers.commentOut(this.contentLines[targetLine], this.isCoffee));
    } else {
      results.push(this.contentLines.splice(targetLine, 1));
    }
  }
  return results;
};

File.prototype.prependDuplicateRefs = function(content) {
  var duplicates, file, hash;
  duplicates = (function() {
    var ref, results;
    ref = this.importRefs;
    results = [];
    for (hash in ref) {
      file = ref[hash];
      if (file.importedCount > 1) {
        results.push(file);
      }
    }
    return results;
  }).call(this);
  if (!duplicates.length) {
    return content;
  }
  return Promise.all(duplicates.map(function(file) {
    return file.compile();
  })).then((function(_this) {
    return function() {
      var assignments, i, len, loader, result, value;
      assignments = [];
      for (i = 0, len = duplicates.length; i < len; i++) {
        file = duplicates[i];
        value = _this.isCoffee && !file.isCoffee ? helpers.formatJsContentForCoffee(file.compiledContent) : file.compiledContent;
        assignments.push("m[" + file.contentReference + "] = " + value);
      }
      loader = helpers.wrapInLoaderClosure(assignments, '\t', _this.isCoffee);
      result = loader + "\n" + content;
      result = _this.options.preventGlobalLeaks ? helpers.wrapInClosure(result, _this.isCoffee) : result;
      return result;
    };
  })(this));
};

File.prototype.compile = function(importerStack) {
  var childImportsPromise;
  if (importerStack == null) {
    importerStack = [];
  }
  if (this.compilePromise) {
    return this.compilePromise;
  } else {
    if (!this.options.recursive && !this.isMain) {
      return (this.compiledContent = this.content);
    }

    /* istanbul ignore next */
    if (!importerStack.includes(this)) {
      importerStack.push(this);
    }
    childImportsPromise = Promise.delay().then((function(_this) {
      return function() {
        return Promise.all(_this.imports.map(function(hash) {
          var childFile;
          childFile = _this.importRefs[hash];
          if (!importerStack.includes(childFile)) {
            return childFile.compile(importerStack);
          }
        }));
      };
    })(this));
    return this.compilePromise = childImportsPromise.then((function(_this) {
      return function(childImports) {
        _this.replaceImports(childImports);
        _this.replaceBadImports(childImports);
        return _this.contentLines.join('\n');
      };
    })(this)).then((function(_this) {
      return function(compiledResult) {
        var modifiedContent;
        switch (false) {
          case !_this.isMain:
            return _this.prependDuplicateRefs(compiledResult);
          case !_this.hasExports:
            return helpers.wrapInExportsClosure(compiledResult, _this.isCoffee, _this.importedCount > 1);
          case !(_this.requiresReturnedClosure || _this.importedCount > 1):
            if (_this.isCoffee) {
              return helpers.wrapInClosure(compiledResult, _this.isCoffee, _this.importedCount > 1);
            } else {
              modifiedContent = helpers.modToReturnLastStatement(compiledResult || (compiledResult = '{}'), _this.filePathSimple);
              if (modifiedContent === 'ExpressionStatement') {
                if (!(_this.importedCount > 1)) {
                  return compiledResult;
                }
                modifiedContent = "return " + compiledResult;
              }
              return helpers.wrapInClosure(modifiedContent, false, _this.importedCount > 1);
            }

            /* istanbul ignore next */
            break;
          case !_this.requiresClosure:
            return helpers.wrapInClosure(compiledResult, _this.isCoffee, _this.importedCount > 1);
          default:
            return compiledResult;
        }
      };
    })(this)).then((function(_this) {
      return function(compiledResult) {
        if (_this.options.toES5 && !_this.isCoffee && _this.isMain) {
          return helpers.transpileES6toES5(compiledResult);
        } else {
          return compiledResult;
        }
      };
    })(this)).then((function(_this) {
      return function(result) {
        return _this.compiledContent = result || '{}';
      };
    })(this));
  }
};

File.instanceCache = {};

module.exports = File;
