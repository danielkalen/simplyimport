// Generated by CoffeeScript 1.10.0
var Browserify, File, PATH, Promise, Streamify, chalk, coffeeCompiler, consoleLabels, fs, helpers, md5, regEx, replaceAsync, uglifier;

Promise = require('bluebird');

fs = Promise.promisifyAll(require('fs'));

replaceAsync = require('string-replace-async');

md5 = require('md5');

PATH = require('path');

chalk = require('chalk');

Streamify = require('streamify-string');

Browserify = require('browserify');

Browserify.prototype.bundleAsync = Promise.promisify(Browserify.prototype.bundle, {
  ctx: Browserify.prototype
});

coffeeCompiler = require('coffee-script');

uglifier = require('uglify-js');

regEx = require('./regex');

helpers = require('./helpers');

consoleLabels = require('./consoleLabels');


/**
 * The object created for each file path the program needs to open/import/read.
 * @param {String} input               	File's path or file's contents
 * @param {Object} state	          	(optional) initial state map to indicate if 'isStream', 'isCoffee', and 'context'
 * @param {Object} importHistory	 	(optional) the import history collected so far since the main faile import
 */

module.exports = File = function(input, options, importRefs, arg) {
  var ref;
  this.options = options;
  this.importRefs = importRefs;
  ref = arg != null ? arg : {}, this.isMain = ref.isMain, this.isCoffee = ref.isCoffee, this.context = ref.context;
  this.input = input;
  this.imports = [];
  this.badImports = [];
  this.lineRefs = {};
  return this;
};

File.prototype.process = function() {
  return Promise.bind(this).then(this.getFilePath).then(this.resolveContext).then(this.checkIfIsCoffee).then(this.getContents);
};

File.prototype.getContents = function() {
  if (this.isMain) {
    this.contentLines = this.input.split('\n');
    return this.content = this.input;
  } else {
    return fs.readFileAsync(this.filePath, {
      encoding: 'utf8'
    }).then((function(_this) {
      return function(content) {
        _this.content = content;
        _this.hash = md5(content);
        _this.contentLines = content.split('\n');
        return content;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          console.error(consoleLabels.error + " File doesn't exist " + (chalk.dim(helpers.simplifyPath(_this.filePath))));
          return Promise.reject(err);
        }
      };
    })(this));
  }
};

File.prototype.getFilePath = function() {
  var inputFileName, parentDir;
  if (this.isMain) {
    return this.context;
  } else if (PATH.extname(this.input)) {
    return this.filePath = this.input;
  } else {
    inputFileName = PATH.basename(this.input);
    parentDir = PATH.dirname(this.input);
    return helpers.getDirListing(parentDir, this.options.dirCache).then((function(_this) {
      return function(parentDirListing) {
        var exactMatch, fileMatch, inputPathMatches, resolvedPath;
        inputPathMatches = parentDirListing.filter(function(targetPath) {
          return targetPath.includes(inputFileName);
        });
        if (!inputPathMatches.length) {
          return _this.filePath = _this.input;
        } else {
          exactMatch = inputPathMatches.find(function(targetPath) {
            return targetPath === inputFileName;
          });
          fileMatch = inputPathMatches.find(function(targetPath) {
            var fileNameSplit;
            fileNameSplit = targetPath.replace(inputFileName, '').split('.');
            return !fileNameSplit[0] && fileNameSplit.length === 2;
          });
          if (fileMatch) {
            return _this.filePath = PATH.join(parentDir, fileMatch);
          } else {
            resolvedPath = PATH.join(parentDir, inputFileName);
            return fs.statAsync(resolvedPath).then(function(pathStats) {
              if (!pathStats.isDirectory()) {
                return _this.filePath = resolvedPath;
              } else {
                return helpers.getDirListing(resolvedPath, _this.options.dirCache).then(function(targetDirListing) {
                  var indexFile;
                  indexFile = targetDirListing.find(function(file) {
                    return file.includes('index');
                  });
                  if (indexFile) {
                    return _this.filePath = PATH.join(parentDir, inputFileName, indexFile);
                  } else {
                    return _this.filePath = PATH.join(parentDir, inputFileName, 'index.js');
                  }
                });
              }
            });
          }
        }
      };
    })(this));
  }
};

File.prototype.resolveContext = function() {
  if (this.isMain) {
    return this.context;
  } else {
    return this.context = helpers.getNormalizedDirname(this.filePath);
  }
};

File.prototype.checkIfIsCoffee = function() {
  return this.isCoffee = this.isMain ? this.isCoffee : PATH.extname(this.filePath).toLowerCase().slice(1) === 'coffee';
};

File.prototype.addLineRef = function(entireLine, targetRef) {
  var base;
  if (entireLine.slice(-1)[0] === '\n') {
    entireLine = entireLine.slice(0, -1);
  }
  if ((base = this.lineRefs)[targetRef] == null) {
    base[targetRef] = [];
  }
  return this.lineRefs[targetRef].push(this.contentLines.indexOf(entireLine));
};

File.prototype.collectImports = function() {
  return this.collectedImports || (this.collectedImports = replaceAsync(this.content, regEx["import"], (function(_this) {
    return function(entireLine, priorContent, spacing, conditions, childPath) {
      var childFile;
      if (conditions == null) {
        conditions = '';
      }
      childPath = childPath.replace(/['"]/g, '').replace(/\s+$/, '');
      childPath = PATH.resolve(_this.context, childPath);
      if (helpers.testForComments(entireLine, _this.isCoffee)) {
        return Promise.resolve();
      } else if (!helpers.testConditions(_this.options.conditions, conditions)) {
        _this.addLineRef(entireLine, childPath);
        _this.badImports.push(childPath);
        return Promise.resolve();
      } else {
        childFile = new File(childPath, _this.options, _this.importRefs);
        return childFile.process().then(function() {
          if (_this.importRefs[childFile.hash] && !_this.importRefs.duplicates[childFile.hash]) {
            _this.importRefs.duplicates[childFile.hash] = helpers.genUniqueVar();
          }
          _this.importRefs[childFile.hash] = childFile;
          _this.imports.push(childFile.hash);
          _this.addLineRef(entireLine, childFile.hash);
          return Promise.resolve();
        });
      }
    };
  })(this)).then((function(_this) {
    return function() {
      var childFileHash;
      if (_this.options.recursive) {
        return Promise.all((function() {
          var i, len, ref, results;
          ref = this.imports;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            childFileHash = ref[i];
            results.push(this.importRefs[childFileHash].collectImports());
          }
          return results;
        }).call(_this));
      }
    };
  })(this)));
};

File.prototype.compile = function() {
  var childFileHash;
  if (!this.options.recursive && !this.isMain) {
    return (this.compiledContent = this.content);
  }
  return Promise.all((function() {
    var i, len, ref, results;
    ref = this.imports;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      childFileHash = ref[i];
      results.push(this.importRefs[childFileHash].compile());
    }
    return results;
  }).call(this)).then((function(_this) {
    return function(childImports) {
      var badImport, childContent, childFile, childHash, i, index, j, k, l, len, len1, len2, len3, ref, ref1, ref2, ref3, targetLine;
      ref = _this.imports;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        childHash = ref[index];
        childFile = _this.importRefs[childHash];
        childContent = childImports[index];
        ref1 = _this.lineRefs[childHash];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          targetLine = ref1[j];
          _this.contentLines[targetLine] = _this.contentLines[targetLine].replace(regEx["import"], function(entireLine, priorContent, spacing, conditions, childPath) {
            if (_this.importRefs.duplicates[childHash]) {
              childContent = _this.importRefs.duplicates[childHash];
            } else {
              if (priorContent && priorContent.replace(/\s/g, '') === '') {
                spacing = priorContent + spacing;
                priorContent = '';
              }
              if (spacing && !priorContent) {
                childContent = helpers.addSpacingToString(childContent, spacing);
              }
              switch (false) {
                case !(_this.isCoffee && !childFile.isCoffee):
                  childContent = helpers.formatJsContentForCoffee(childContent);
                  break;
                case !(childFile.isCoffee && !_this.isCoffee):
                  if (_this.options.compileCoffeeChildren) {
                    childContent = coffeeCompiler.compile(childContent, {
                      'bare': true
                    });
                  } else {
                    throw new Error(consoleLabels.error + " You're attempting to import a Coffee file into a JS file (which will provide a broken file), rerun this import with -C or --compile-coffee-children");
                  }
              }
              if (_this.options.uglify) {
                childContent = uglifier.minify(childContent, {
                  'fromString': true,
                  'compressor': {
                    'keep_fargs': true,
                    'unused': false
                  }
                }).code;
              }
            }
            if (priorContent && childContent) {
              childContent = priorContent + spacing + childContent;
            }
            return childContent;
          });
        }
      }
      ref2 = _this.badImports;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        badImport = ref2[k];
        ref3 = _this.lineRefs[badImport];
        for (l = 0, len3 = ref3.length; l < len3; l++) {
          targetLine = ref3[l];
          if (_this.options.preserve) {
            _this.contentLines[targetLine] = helpers.commentOut(_this.contentLines[targetLine], _this.isCoffee, true);
          } else {
            _this.contentLines.splice(targetLine, 1);
          }
        }
      }
      return _this.contentLines.join('\n');
    };
  })(this)).then((function(_this) {
    return function(compiledResult) {
      var assignments, childFile, declaration, importHash, ref, value, varName;
      if (!_this.isMain) {
        return _this.compiledContent = compiledResult;
      } else {
        if (Object.keys(_this.importRefs.duplicates).length) {
          assignments = [];
          ref = _this.importRefs.duplicates;
          for (importHash in ref) {
            varName = ref[importHash];
            childFile = _this.importRefs[importHash];
            declaration = !_this.isCoffee ? "var " + varName : varName;
            if (_this.isCoffee) {
              value = "do ()=> \n" + (helpers.addSpacingToString(childFile.content, '\t'));
            } else {
              value = "(function(){";
              value += childFile.contentLines.length === 1 && !childFile.compiledContent.startsWith('var') ? "return " + childFile.compiledContent : childFile.compiledContent;
              value += "}).call(this)";
            }
            assignments.push(declaration + " = " + value);
          }
          assignments = assignments.reverse().join('\n');
          if (_this.isCoffee) {
            compiledResult = "do ()=> " + (helpers.addSpacingToString(assignments)) + "\n " + (helpers.addSpacingToString(compiledResult));
          } else {
            compiledResult = "(function(){\n " + assignments + "\n " + compiledResult + "\n }).call(this);";
          }
        }
        if (regEx.commonJS["import"].test(compiledResult) || regEx.commonJS["export"].test(compiledResult)) {
          compiledResult = _this.isCoffee ? coffeeCompiler.compile(compiledResult, {
            'bare': true
          }) : compiledResult;
          return Browserify(Streamify(compiledResult), {
            basedir: _this.context
          }).bundleAsync().then(function(contentBuffer) {
            compiledResult = contentBuffer.toString();
            if (_this.isCoffee) {
              compiledResult = helpers.formatJsContentForCoffee(compiledResult);
            }
            return _this.compiledContent = compiledResult;
          });
        } else {
          return _this.compiledContent = compiledResult;
        }
      }
    };
  })(this));
};
