// Generated by CoffeeScript 1.10.0
var File, PATH, Promise, chalk, coffeeCompiler, consoleLabels, fs, helpers, md5, regEx, replaceAsync, uglifier;

Promise = require('bluebird');

fs = Promise.promisifyAll(require('fs-extra'));

replaceAsync = require('string-replace-async');

md5 = require('md5');

PATH = require('path');

chalk = require('chalk');

coffeeCompiler = require('coffee-script');

uglifier = require('uglify-js');

regEx = require('./regex');

helpers = require('./helpers');

consoleLabels = require('./consoleLabels');


/**
 * The object created for each file path the program needs to open/import/read.
 * @param {String} input               	File's path or file's contents
 * @param {Object} state	          	(optional) initial state map to indicate if 'isStream', 'isCoffee', and 'context'
 * @param {Object} importHistory	 	(optional) the import history collected so far since the main faile import
 */

module.exports = File = function(input, options, importRefs, arg) {
  var ref;
  this.options = options;
  this.importRefs = importRefs;
  ref = arg != null ? arg : {}, this.isMain = ref.isMain, this.isCoffee = ref.isCoffee, this.context = ref.context;
  this.input = input;
  this.imports = [];
  this.badImports = [];
  this.importMemberRefs = [];
  this.lineRefs = [];
  this.orderRefs = [];
  return this;
};

File.prototype.process = function() {
  return Promise.bind(this).then(this.getFilePath).then(this.resolveContext).then(this.checkIfIsCoffee).then(this.getContents).then(this.checkIfIsBrowserified);
};

File.prototype.getContents = function() {
  if (this.isMain) {
    this.contentLines = this.input.split('\n');
    return this.content = this.input;
  } else {
    return fs.readFileAsync(this.filePath, {
      encoding: 'utf8'
    }).then((function(_this) {
      return function(content) {
        _this.content = content;
        _this.hash = md5(content);
        _this.contentLines = content.split('\n');
        return content;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        console.error(consoleLabels.error + " File/module doesn't exist " + (chalk.dim(helpers.simplifyPath(_this.filePath))));
        return Promise.reject(err);
      };
    })(this));
  }
};

File.prototype.getFilePath = function() {
  var inputFileName, parentDir;
  if (this.isMain) {
    return this.context;
  } else if (PATH.extname(this.input)) {
    return this.filePath = this.input;
  } else {
    inputFileName = PATH.basename(this.input);
    parentDir = PATH.dirname(this.input);
    return helpers.getDirListing(parentDir, this.options.dirCache).then((function(_this) {
      return function(parentDirListing) {
        var exactMatch, fileMatch, inputPathMatches, resolvedPath;
        inputPathMatches = parentDirListing.filter(function(targetPath) {
          return targetPath.includes(inputFileName);
        });
        if (!inputPathMatches.length) {
          return _this.filePath = _this.input;
        } else {
          exactMatch = inputPathMatches.find(function(targetPath) {
            return targetPath === inputFileName;
          });
          fileMatch = inputPathMatches.find(function(targetPath) {
            var fileNameSplit;
            fileNameSplit = targetPath.replace(inputFileName, '').split('.');
            return !fileNameSplit[0] && fileNameSplit.length === 2;
          });
          if (fileMatch) {
            return _this.filePath = PATH.join(parentDir, fileMatch);
          } else {
            resolvedPath = PATH.join(parentDir, inputFileName);
            return fs.statAsync(resolvedPath).then(function(pathStats) {
              if (!pathStats.isDirectory()) {
                return _this.filePath = resolvedPath;
              } else {
                return helpers.getDirListing(resolvedPath, _this.options.dirCache).then(function(targetDirListing) {
                  var indexFile;
                  indexFile = targetDirListing.find(function(file) {
                    return file.includes('index');
                  });
                  if (indexFile) {
                    return _this.filePath = PATH.join(parentDir, inputFileName, indexFile);
                  } else {
                    return _this.filePath = PATH.join(parentDir, inputFileName, 'index.js');
                  }
                });
              }
            });
          }
        }
      };
    })(this));
  }
};

File.prototype.resolveContext = function() {
  if (this.isMain) {
    return this.context;
  } else {
    return this.context = helpers.getNormalizedDirname(this.filePath);
  }
};

File.prototype.checkIfIsCoffee = function() {
  return this.isCoffee = this.isMain ? this.isCoffee : PATH.extname(this.filePath).toLowerCase().slice(1) === 'coffee';
};

File.prototype.checkIfIsBrowserified = function() {
  return this.isBrowserified = this.content.includes('.code="MODULE_NOT_FOUND"');
};

File.prototype.addLineRef = function(entireLine, targetRef, contentLines, offset) {
  var existingRef, lineIndex;
  if (contentLines == null) {
    contentLines = this.contentLines;
  }
  if (offset == null) {
    offset = 0;
  }
  lineIndex = contentLines.indexOf(entireLine) + offset;
  existingRef = this.lineRefs.findIndex(function(existingLineRef) {
    return existingLineRef === lineIndex;
  });
  if (existingRef >= 0) {
    return this.addLineRef(entireLine, targetRef, contentLines.slice(lineIndex + 1), lineIndex + 1);
  } else {
    return this.lineRefs[targetRef] = lineIndex;
  }
};

File.prototype.collectImports = function() {
  return this.collectedImports || (this.collectedImports = Promise.resolve().then((function(_this) {
    return function() {
      var processImport;
      processImport = function(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members) {
        var orderRefIndex;
        if (conditions == null) {
          conditions = '';
        }
        if (defaultMember == null) {
          defaultMember = '';
        }
        if (members == null) {
          members = '';
        }
        orderRefIndex = _this.orderRefs.push(entireLine) - 1;
        childPath = childPath.replace(/['"]/g, '').replace(/[;\s]+$/, '');
        return helpers.resolveModulePath(childPath, _this.context).then(function(modulePath) {
          var childFile;
          childPath = modulePath || PATH.resolve(_this.context, childPath);
          if (helpers.testForComments(entireLine, _this.isCoffee)) {
            return Promise.resolve();
          } else if (!helpers.testConditions(_this.options.conditions, conditions)) {
            _this.badImports.push(childPath);
            _this.addLineRef(entireLine, 'bad_' + (_this.badImports.length - 1));
            return Promise.resolve();
          } else {
            childFile = new File(childPath, _this.options, _this.importRefs);
            return childFile.process().then(function() {
              if (_this.importRefs[childFile.hash] && !_this.importRefs.duplicates[childFile.hash]) {
                _this.importRefs.duplicates[childFile.hash] = helpers.genUniqueVar();
              }
              _this.importRefs[childFile.hash] = childFile;
              _this.imports[orderRefIndex] = childFile.hash;
              _this.orderRefs[orderRefIndex] = childFile.hash;
              _this.addLineRef(entireLine, orderRefIndex);
              if (defaultMember || members) {
                _this.importMemberRefs[orderRefIndex] = {
                  "default": defaultMember,
                  members: helpers.parseMembersString(members)
                };
                childFile.hasUsefulExports = true;
              } else if (priorContent) {
                childFile.hasUsefulExports = true;
              }
              return Promise.resolve();
            });
          }
        });
      };
      return replaceAsync(_this.content, regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath) {
        return processImport(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members);
      }).then(function() {
        if (_this.isBrowserified) {
          return;
        }
        return replaceAsync(_this.content, regEx.commonJS["import"], function(entireLine, priorContent, childPath) {
          return processImport(childPath, entireLine, priorContent);
        });
      });
    };
  })(this)).then((function(_this) {
    return function() {
      if (regEx["export"].test(_this.content) || regEx.commonJS["export"].test(_this.content)) {
        if (!_this.isBrowserified) {
          _this.hasExports = true;
        }
        return _this.normalizeExports();
      }
    };
  })(this)).then((function(_this) {
    return function() {
      var childFileHash;
      if (_this.options.recursive) {
        return Promise.all((function() {
          var i, len, ref, results;
          ref = this.imports;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            childFileHash = ref[i];
            results.push(this.importRefs[childFileHash].collectImports());
          }
          return results;
        }).call(_this));
      }
    };
  })(this)));
};

File.prototype.normalizeExports = function() {
  if (!this.isBrowserified) {
    this.content.replace(regEx.commonJS["export"], (function(_this) {
      return function(entireLine, priorContent, operator, trailingContent) {
        var lineIndex;
        if (operator === '=') {
          operator = " " + operator;
        }
        lineIndex = _this.contentLines.indexOf(entireLine);
        return _this.contentLines[lineIndex] = priorContent + "exports" + operator + trailingContent;
      };
    })(this));
  }
  return this.content.replace(regEx["export"], (function(_this) {
    return function(entireLine, exportMap, exportType, label, trailingContent) {
      var labelName, lineIndex, value;
      lineIndex = _this.contentLines.indexOf(entireLine);
      switch (false) {
        case !exportMap:
          return _this.contentLines[lineIndex] = "exports = " + (helpers.normalizeExportMap(exportMap)) + trailingContent;
        case exportType !== 'default':
          return _this.contentLines[lineIndex] = "exports['*default*'] = " + label + trailingContent;
        case !(exportType != null ? exportType.includes('function') : void 0):
          labelName = label.replace(/\(.*?\).*$/, '');
          value = trailingContent.includes('=>') ? "" + label + trailingContent : exportType + " " + label + trailingContent;
          return _this.contentLines[lineIndex] = "exports['" + labelName + "'] = " + value;
        case exportType !== 'class':
          return _this.contentLines[lineIndex] = "exports['" + label + "'] = " + exportType + " " + label + trailingContent;
        case !exportType:
          return _this.contentLines[lineIndex] = exportType + " " + label + " = exports['" + label + "'] = " + (trailingContent.replace(/^\s*\=\s*/, ''));
        case !(!exportType && !exportMap):
          label = trailingContent.match(/^\S+/)[0];
          return _this.contentLines[lineIndex] = "exports['" + label + "'] = " + trailingContent;
      }
    };
  })(this));
};

File.prototype.replaceImports = function(childImports) {
  var childContent, childFile, childHash, i, importIndex, len, ref, replaceLine, targetLine;
  ref = this.imports;
  for (importIndex = i = 0, len = ref.length; i < len; importIndex = ++i) {
    childHash = ref[importIndex];
    childFile = this.importRefs[childHash];
    childContent = childImports[importIndex];
    targetLine = this.lineRefs[importIndex];
    replaceLine = (function(_this) {
      return function(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members) {
        var alias, exportedName, importData, key, ref1, varPrefix;
        if (_this.importRefs.duplicates[childHash]) {
          childContent = _this.importRefs.duplicates[childHash];
        } else {
          if (priorContent && priorContent.replace(/\s/g, '') === '') {
            spacing = priorContent + spacing;
            priorContent = '';
          }
          if (spacing && !priorContent) {
            childContent = helpers.addSpacingToString(childContent, spacing);
          }
          switch (false) {
            case !(_this.isCoffee && !childFile.isCoffee):
              childContent = helpers.formatJsContentForCoffee(childContent);
              break;
            case !(childFile.isCoffee && !_this.isCoffee):
              if (_this.options.compileCoffeeChildren) {
                childContent = coffeeCompiler.compile(childContent, {
                  'bare': true
                });
              } else {
                throw new Error(consoleLabels.error + " You're attempting to import a Coffee file into a JS file (which will provide a broken file), rerun this import with -C or --compile-coffee-children");
              }
          }
          if (_this.options.uglify) {
            childContent = uglifier.minify(childContent, {
              'fromString': true,
              'compressor': {
                'keep_fargs': true,
                'unused': false
              }
            }).code;
          }
        }
        if (trailingContent.startsWith(')')) {
          if (priorContent) {
            spacing += '(';
          } else {
            priorContent = '(';
            spacing = '';
          }
        }
        if (childFile.hasUsefulExports && (importData = _this.importMemberRefs[importIndex])) {
          _this.requiresClosure = true;
          exportedName = helpers.genUniqueVar();
          varPrefix = _this.isCoffee ? '' : 'var ';
          childContent = "" + varPrefix + exportedName + " = " + childContent + ";\n";
          if (importData["default"]) {
            childContent += "" + varPrefix + importData["default"] + " = " + exportedName + "['*default*'];\n";
          }
          ref1 = importData.members;
          for (key in ref1) {
            alias = ref1[key];
            if (key === '!*!') {
              childContent += "" + varPrefix + alias + " = " + exportedName + ";\n";
            } else {
              childContent += "" + varPrefix + alias + " = " + exportedName + "['" + key + "'];\n";
            }
          }
        }
        if (priorContent && childContent) {
          childContent = priorContent + spacing + childContent;
        }
        return childContent + trailingContent;
      };
    })(this);
    if (regEx["import"].test(this.contentLines[targetLine])) {
      this.contentLines[targetLine] = this.contentLines[targetLine].replace(regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath, trailingContent) {
        return replaceLine(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members);
      });
    } else {
      this.contentLines[targetLine] = this.contentLines[targetLine].replace(regEx.commonJS["import"], function(entireLine, priorContent, childPath, trailingContent) {
        return replaceLine(childPath, entireLine, priorContent, trailingContent, '');
      });
    }
  }
};

File.prototype.replaceBadImports = function() {
  var badImport, i, index, len, ref, results, targetLine;
  ref = this.badImports;
  results = [];
  for (index = i = 0, len = ref.length; i < len; index = ++i) {
    badImport = ref[index];
    targetLine = this.lineRefs['bad_' + index];
    if (this.options.preserve) {
      results.push(this.contentLines[targetLine] = helpers.commentOut(this.contentLines[targetLine], this.isCoffee));
    } else {
      results.push(this.contentLines.splice(targetLine, 1));
    }
  }
  return results;
};

File.prototype.prependDuplicateRefs = function(content) {
  var assignments, childContent, childFile, declaration, importHash, ref, value, varName;
  if (Object.keys(this.importRefs.duplicates).length) {
    this.requiresClosure = true;
    assignments = [];
    ref = this.importRefs.duplicates;
    for (importHash in ref) {
      varName = ref[importHash];
      childFile = this.importRefs[importHash];
      declaration = !this.isCoffee ? "var " + varName : varName;
      if (this.isCoffee) {
        value = helpers.wrapInClosure(childFile.compiledContent, this.isCoffee);
      } else {
        childContent = helpers.modToReturnLastStatement(childFile.compiledContent);
        value = helpers.wrapInClosure(childContent, this.isCoffee);
      }
      assignments.push(declaration + " = " + value);
    }
    assignments = assignments.reverse().join('\n');
    content = assignments + "\n" + content;
  }
  return content;
};

File.prototype.compile = function() {
  var childFileHash;
  if (!this.options.recursive && !this.isMain) {
    return (this.compiledContent = this.content);
  }
  return Promise.all((function() {
    var i, len, ref, results;
    ref = this.imports;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      childFileHash = ref[i];
      results.push(this.importRefs[childFileHash].compile());
    }
    return results;
  }).call(this)).then((function(_this) {
    return function(childImports) {
      _this.replaceImports(childImports);
      _this.replaceBadImports(childImports);
      return _this.contentLines.join('\n');
    };
  })(this)).then((function(_this) {
    return function(compiledResult) {
      if (_this.hasExports) {
        compiledResult = helpers.wrapInExportsClosure(compiledResult, _this.isCoffee);
      }
      if (_this.isMain) {
        compiledResult = _this.prependDuplicateRefs(compiledResult);
      }
      if (_this.requiresClosure && _this.options.preventGlobalLeaks) {
        compiledResult = helpers.wrapInClosure(compiledResult, _this.isCoffee);
      }
      return _this.compiledContent = compiledResult;
    };
  })(this));
};
