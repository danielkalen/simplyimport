// Generated by CoffeeScript 1.10.0
var File, PATH, Promise, chalk, coffeeCompiler, consoleLabels, fs, helpers, md5, regEx, replaceAsync, resolveModule, uglifier;

Promise = require('bluebird');

fs = Promise.promisifyAll(require('fs-extra'));

resolveModule = Promise.promisify(require('resolve'));

replaceAsync = require('string-replace-async');

md5 = require('md5');

PATH = require('path');

chalk = require('chalk');

coffeeCompiler = require('coffee-script');

uglifier = require('uglify-js');

regEx = require('./regex');

helpers = require('./helpers');

consoleLabels = require('./consoleLabels');


/**
 * The object created for each file path the program needs to open/import/read.
 * @param {String} input               	File's path or file's contents
 * @param {Object} state	          	(optional) initial state map to indicate if 'isStream', 'isCoffee', and 'context'
 * @param {Object} importHistory	 	(optional) the import history collected so far since the main faile import
 */

File = function(input, options, importRefs1, arg) {
  var ref;
  this.options = options;
  this.importRefs = importRefs1;
  ref = arg != null ? arg : {}, this.isMain = ref.isMain, this.isCoffee = ref.isCoffee, this.context = ref.context;
  this.input = input;
  this.imports = [];
  this.badImports = [];
  this.importMemberRefs = [];
  this.lineRefs = [];
  this.orderRefs = [];
  this.cacheRef = this.isMain ? '*main*' : input;
  return File.instanceCache[this.cacheRef] || this;
};

File.prototype.process = function() {
  return Promise.bind(this).then(this.getFilePath).then(this.resolveContext).then(this.checkIfIsCoffee).then(this.getContents).then(this.checkIfIsBrowserified).then((function(_this) {
    return function() {
      return File.instanceCache[_this.cacheRef] = _this;
    };
  })(this));
};

File.prototype.getContents = function() {
  if (this.isMain) {
    this.contentLines = this.input.split('\n');
    this.hash = md5(this.input);
    return this.content = this.input;
  } else {
    return fs.readFileAsync(this.filePath, {
      encoding: 'utf8'
    }).then((function(_this) {
      return function(content) {
        _this.content = content;
        _this.hash = md5(content);
        _this.contentLines = content.split('\n');
        return content;
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        console.error(consoleLabels.error + " File/module doesn't exist " + (chalk.dim(helpers.simplifyPath(_this.filePath))));
        return Promise.reject(err);
      };
    })(this));
  }
};

File.prototype.getFilePath = function() {
  var inputFileName, parentDir;
  if (this.isMain) {
    return this.context;
  } else if (PATH.extname(this.input)) {
    return this.filePath = this.input;
  } else {
    inputFileName = PATH.basename(this.input);
    parentDir = PATH.dirname(this.input);
    return helpers.getDirListing(parentDir, this.options.dirCache).then((function(_this) {
      return function(parentDirListing) {
        var exactMatch, fileMatch, inputPathMatches, resolvedPath;
        inputPathMatches = parentDirListing.filter(function(targetPath) {
          return targetPath.includes(inputFileName);
        });
        if (!inputPathMatches.length) {
          return _this.filePath = _this.input;
        } else {
          exactMatch = inputPathMatches.find(function(targetPath) {
            return targetPath === inputFileName;
          });
          fileMatch = inputPathMatches.find(function(targetPath) {
            var fileNameSplit;
            fileNameSplit = targetPath.replace(inputFileName, '').split('.');
            return !fileNameSplit[0] && fileNameSplit.length === 2;
          });
          if (fileMatch) {
            return _this.filePath = PATH.join(parentDir, fileMatch);
          } else {
            resolvedPath = PATH.join(parentDir, inputFileName);
            return fs.statAsync(resolvedPath).then(function(pathStats) {
              if (!pathStats.isDirectory()) {
                return _this.filePath = resolvedPath;
              } else {
                return helpers.getDirListing(resolvedPath, _this.options.dirCache).then(function(targetDirListing) {
                  var indexFile;
                  indexFile = targetDirListing.find(function(file) {
                    return file.includes('index');
                  });
                  if (indexFile) {
                    return _this.filePath = PATH.join(parentDir, inputFileName, indexFile);
                  } else {
                    return _this.filePath = PATH.join(parentDir, inputFileName, 'index.js');
                  }
                });
              }
            });
          }
        }
      };
    })(this));
  }
};

File.prototype.resolveContext = function() {
  if (this.isMain) {
    return this.context;
  } else {
    return this.context = helpers.getNormalizedDirname(this.filePath);
  }
};

File.prototype.checkIfIsCoffee = function() {
  return this.isCoffee = this.isMain ? this.isCoffee : PATH.extname(this.filePath).toLowerCase().slice(1) === 'coffee';
};

File.prototype.checkIfIsBrowserified = function() {
  return this.isBrowserified = this.content.includes('.code="MODULE_NOT_FOUND"');
};

File.prototype.checkIfImportsFile = function(targetFile) {
  var checkArray, importRefs, iteratedArrays;
  iteratedArrays = [this.imports];
  importRefs = this.importRefs;
  checkArray = (function(_this) {
    return function(importsArray) {
      return importsArray.includes(targetFile.hash) || importsArray.find(function(importHash) {
        var currentFile;
        currentFile = importRefs[importHash];
        if (iteratedArrays.includes(currentFile.imports)) {
          return currentFile;
        } else {
          iteratedArrays.push(currentFile.imports);
          return checkArray(currentFile.imports);
        }
      });
    };
  })(this);
  return checkArray(this.imports);
};

File.prototype.addLineRef = function(entireLine, targetRef, contentLines, offset) {
  var existingRef, lineIndex;
  if (contentLines == null) {
    contentLines = this.contentLines;
  }
  if (offset == null) {
    offset = 0;
  }
  lineIndex = contentLines.indexOf(entireLine) + offset;
  existingRef = this.lineRefs.findIndex(function(existingLineRef) {
    return existingLineRef === lineIndex;
  });
  if (existingRef >= 0) {
    return this.addLineRef(entireLine, targetRef, contentLines.slice(lineIndex + 1), lineIndex + 1);
  } else {
    return this.lineRefs[targetRef] = lineIndex;
  }
};

File.prototype.processImport = function(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members) {
  var orderRefIndex, origChildPath;
  if (conditions == null) {
    conditions = '';
  }
  if (defaultMember == null) {
    defaultMember = '';
  }
  if (members == null) {
    members = '';
  }
  orderRefIndex = this.orderRefs.push(entireLine) - 1;
  childPath = origChildPath = childPath.replace(/['"]/g, '').replace(/[;\s]+$/, '');
  return helpers.resolveModulePath(childPath, this.context).then((function(_this) {
    return function(modulePath) {
      var childFile;
      childPath = modulePath || PATH.resolve(_this.context, childPath);
      if (helpers.testForComments(entireLine, _this.isCoffee) || helpers.testForOuterString(entireLine) || resolveModule.isCore(origChildPath)) {
        return Promise.resolve();
      } else if (!helpers.testConditions(_this.options.conditions, conditions)) {
        _this.badImports.push(childPath);
        _this.addLineRef(entireLine, 'bad_' + (_this.badImports.length - 1));
        return Promise.resolve();
      } else {
        childFile = new File(childPath, _this.options, _this.importRefs);
        return childFile.process().then(function() {
          if (_this.importRefs[childFile.hash] && !_this.importRefs.duplicates[childFile.hash]) {
            _this.importRefs.duplicates[childFile.hash] = helpers.genUniqueVar();
          }
          _this.importRefs[childFile.hash] = childFile;
          _this.imports[orderRefIndex] = childFile.hash;
          _this.orderRefs[orderRefIndex] = childFile.hash;
          _this.addLineRef(entireLine, orderRefIndex);
          if (defaultMember || members) {
            _this.importMemberRefs[orderRefIndex] = {
              "default": defaultMember,
              members: helpers.parseMembersString(members)
            };
            childFile.hasUsefulExports = true;
          } else if (priorContent) {
            childFile.hasUsefulExports = true;
          }
          return Promise.resolve();
        });
      }
    };
  })(this));
};

File.prototype.collectImports = function() {
  if (this.collectedImports) {
    return this.collectedImports;
  } else {
    this.collectedImports = Promise.resolve().then((function(_this) {
      return function() {
        return replaceAsync(_this.content, regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath) {
          return _this.processImport(childPath, entireLine, priorContent, spacing, conditions, defaultMember, members);
        });
      };
    })(this)).then((function(_this) {
      return function() {
        if (!_this.isBrowserified) {
          return replaceAsync(_this.content, regEx.commonJS["import"], function(entireLine, priorContent, childPath) {
            return _this.processImport(childPath, entireLine, priorContent);
          });
        }
      };
    })(this));
    return this.collectedImports.then((function(_this) {
      return function() {
        if (regEx["export"].test(_this.content) || regEx.commonJS["export"].test(_this.content)) {
          if (!_this.isBrowserified) {
            _this.hasExports = true;
          }
          return _this.normalizeExports();
        }
      };
    })(this)).then((function(_this) {
      return function() {
        if (_this.options.recursive) {
          return Promise.all(_this.imports.map(function(childFileHash) {
            return _this.importRefs[childFileHash];
          }).filter(function(file) {
            return !file.checkIfImportsFile(_this);
          }).map(function(file) {
            return file.collectImports();
          }));
        }
      };
    })(this));
  }
};

File.prototype.normalizeExports = function() {
  if (!this.isBrowserified) {
    this.content.replace(regEx.commonJS["export"], (function(_this) {
      return function(entireLine, priorContent, operator, trailingContent) {
        var lineIndex;
        if (operator === '=') {
          operator = " " + operator;
        }
        lineIndex = _this.contentLines.indexOf(entireLine);
        return _this.contentLines[lineIndex] = priorContent + "exports" + operator + trailingContent;
      };
    })(this));
  }
  return this.content.replace(regEx["export"], (function(_this) {
    return function(entireLine, exportMap, exportType, label, trailingContent) {
      var labelName, lineIndex, value;
      lineIndex = _this.contentLines.indexOf(entireLine);
      switch (false) {
        case !exportMap:
          return _this.contentLines[lineIndex] = "exports = " + (helpers.normalizeExportMap(exportMap)) + trailingContent;
        case exportType !== 'default':
          return _this.contentLines[lineIndex] = "exports['*default*'] = " + label + trailingContent;
        case !(exportType != null ? exportType.includes('function') : void 0):
          labelName = label.replace(/\(.*?\).*$/, '');
          value = trailingContent.includes('=>') ? "" + label + trailingContent : exportType + " " + label + trailingContent;
          return _this.contentLines[lineIndex] = "exports['" + labelName + "'] = " + value;
        case exportType !== 'class':
          return _this.contentLines[lineIndex] = "exports['" + label + "'] = " + exportType + " " + label + trailingContent;
        case !exportType:
          return _this.contentLines[lineIndex] = exportType + " " + label + " = exports['" + label + "'] = " + (trailingContent.replace(/^\s*\=\s*/, ''));
        case !(!exportType && !exportMap):
          label = trailingContent.match(/^\S+/)[0];
          return _this.contentLines[lineIndex] = "exports['" + label + "'] = " + trailingContent;
      }
    };
  })(this));
};

File.prototype.replaceImports = function(childImports) {
  this.imports.forEach((function(_this) {
    return function(childHash, importIndex) {
      var childContent, childFile, replaceLine, targetLine;
      childFile = _this.importRefs[childHash];
      childContent = childImports[importIndex];
      targetLine = _this.lineRefs[importIndex];
      replaceLine = function(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members) {
        var alias, exportedName, importData, key, ref, varPrefix;
        if (_this.importRefs.duplicates[childHash]) {
          childContent = _this.importRefs.duplicates[childHash];
        } else {
          if (priorContent && priorContent.replace(/\s/g, '') === '') {
            spacing = priorContent + spacing;
            priorContent = '';
          }
          if (spacing && !priorContent) {
            childContent = helpers.addSpacingToString(childContent, spacing);
          }
          switch (false) {
            case !(_this.isCoffee && !childFile.isCoffee):
              childContent = helpers.formatJsContentForCoffee(childContent);
              break;
            case !(childFile.isCoffee && !_this.isCoffee):
              if (_this.options.compileCoffeeChildren) {
                childContent = coffeeCompiler.compile(childContent, {
                  'bare': true
                });
              } else {
                throw new Error(consoleLabels.error + " You're attempting to import a Coffee file into a JS file (which will provide a broken file), rerun this import with -C or --compile-coffee-children");
              }
          }
          if (_this.options.uglify) {
            childContent = uglifier.minify(childContent, {
              'fromString': true,
              'compressor': {
                'keep_fargs': true,
                'unused': false
              }
            }).code;
          }
        }
        if (trailingContent.startsWith(')')) {
          if (priorContent) {
            spacing += '(';
          } else {
            priorContent = '(';
            spacing = '';
          }
        }
        if (childFile.hasUsefulExports && (importData = _this.importMemberRefs[importIndex])) {
          _this.requiresClosure = true;
          exportedName = helpers.genUniqueVar();
          varPrefix = _this.isCoffee ? '' : 'var ';
          childContent = "" + varPrefix + exportedName + " = " + childContent + ";\n";
          if (importData["default"]) {
            childContent += "" + varPrefix + importData["default"] + " = " + exportedName + "['*default*'];\n";
          }
          ref = importData.members;
          for (key in ref) {
            alias = ref[key];
            if (key === '!*!') {
              childContent += "" + varPrefix + alias + " = " + exportedName + ";\n";
            } else {
              childContent += "" + varPrefix + alias + " = " + exportedName + "['" + key + "'];\n";
            }
          }
        }
        if (priorContent && childContent) {
          childContent = priorContent + spacing + childContent;
        }
        return childContent + trailingContent;
      };
      if (regEx["import"].test(_this.contentLines[targetLine])) {
        return _this.contentLines[targetLine] = _this.contentLines[targetLine].replace(regEx["import"], function(entireLine, priorContent, spacing, conditions, defaultMember, members, childPath, trailingContent) {
          return replaceLine(childPath, entireLine, priorContent, trailingContent, spacing, conditions, defaultMember, members);
        });
      } else {
        return _this.contentLines[targetLine] = _this.contentLines[targetLine].replace(regEx.commonJS["import"], function(entireLine, priorContent, childPath, trailingContent) {
          return replaceLine(childPath, entireLine, priorContent, trailingContent, '');
        });
      }
    };
  })(this));
};

File.prototype.replaceBadImports = function() {
  var badImport, i, index, len, ref, results, targetLine;
  ref = this.badImports;
  results = [];
  for (index = i = 0, len = ref.length; i < len; index = ++i) {
    badImport = ref[index];
    targetLine = this.lineRefs['bad_' + index];
    if (this.options.preserve) {
      results.push(this.contentLines[targetLine] = helpers.commentOut(this.contentLines[targetLine], this.isCoffee));
    } else {
      results.push(this.contentLines.splice(targetLine, 1));
    }
  }
  return results;
};

File.prototype.prependDuplicateRefs = function(content) {
  var assignments, childContent, childFile, declaration, importHash, ref, value, varName;
  if (Object.keys(this.importRefs.duplicates).length) {
    this.requiresClosure = true;
    assignments = [];
    ref = this.importRefs.duplicates;
    for (importHash in ref) {
      varName = ref[importHash];
      childFile = this.importRefs[importHash];
      declaration = !this.isCoffee ? "var " + varName : varName;
      if (this.isCoffee) {
        value = helpers.wrapInClosure(childFile.compiledContent, this.isCoffee);
      } else {
        childContent = helpers.modToReturnLastStatement(childFile.compiledContent);
        value = helpers.wrapInClosure(childContent, this.isCoffee);
      }
      assignments.push(declaration + " = " + value);
    }
    assignments = assignments.reverse().join('\n');
    content = assignments + "\n" + content;
  }
  return content;
};

File.prototype.compile = function(importer) {
  if (this.compilePromise) {
    return this.compilePromise;
  } else {
    if (!this.options.recursive && !this.isMain) {
      return (this.compiledContent = this.content);
    }
    return this.compilePromise = Promise.all(this.imports.map((function(_this) {
      return function(childHash) {
        if (_this.importRefs[childHash] !== importer) {
          return _this.importRefs[childHash].compile(_this);
        }
      };
    })(this))).then((function(_this) {
      return function(childImports) {
        _this.replaceImports(childImports);
        _this.replaceBadImports(childImports);
        return _this.contentLines.join('\n');
      };
    })(this)).then((function(_this) {
      return function(compiledResult) {
        if (_this.hasExports) {
          compiledResult = helpers.wrapInExportsClosure(compiledResult, _this.isCoffee);
        }
        if (_this.isMain) {
          compiledResult = _this.prependDuplicateRefs(compiledResult);
        }
        if (_this.requiresClosure && _this.options.preventGlobalLeaks) {
          compiledResult = helpers.wrapInClosure(compiledResult, _this.isCoffee);
        }
        return _this.compiledContent = compiledResult;
      };
    })(this));
  }
};

File.instanceCache = {};

module.exports = File;
