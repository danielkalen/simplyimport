#!/usr/bin/env node
// Generated by CoffeeScript 1.10.0
(function() {
  var applyReplace, args, checkIfInputExists, conditionsPassed, extRegEx, extend, fs, getFileContents, getNormalizedDirname, help, importHistory, importRegEx, input, notRecursive, options, output, outputIsFile, path, shouldPreserve, shouldStdout, shouldUglify, startReplacement, uglify, yargs;

  applyIncludesPolyfill();

  options = {
    'i': {
      alias: 'input',
      demand: true,
      describe: 'Path of the file to compile. Can be relative or absolute.',
      type: 'string'
    },
    'o': {
      alias: 'output',
      describe: 'Path to write the compiled file to. Can be a file, or directory. If omitted the compiled result will be written to stdout.',
      type: 'string'
    },
    's': {
      alias: 'stdout',
      describe: 'Output the compiled result to stdout. (Occurs by default if no output argument supplied.)',
      type: 'boolean'
    },
    'u': {
      alias: 'uglify',
      describe: 'Uglify/minify the compiled file.',
      "default": false,
      type: 'boolean'
    },
    'n': {
      alias: 'notrecursive',
      describe: 'Don\'t attend/follow @import directives inside imported files.',
      "default": false,
      type: 'boolean'
    },
    'p': {
      alias: 'preserve',
      describe: '@import directives that have unmatched conditions should be kept in the file.',
      "default": false,
      type: 'boolean'
    },
    'c': {
      alias: 'conditions',
      describe: 'Specify the conditions that @import directives with conditions should match against. Syntax: -c condA condB condC...',
      type: 'array'
    }
  };

  fs = require('fs');

  path = require('path');

  uglify = require('uglify-js');

  extend = require('object-extend');

  yargs = require('yargs').usage("Usage: simplyimport -i <input> -o <output> -[u|s|n|p|c] \nDirective syntax: // @import {<conditions, separated by commas>} <filepath>").options(options).help('h').alias('h', 'help');

  args = yargs.argv;

  extRegEx = /.+\.(js|coffee)$/i;

  importRegEx = /(\s*)?(?:\/\/|\#)\s*?@import\s*(?:\{(.+)\})?\s*(.+)/ig;

  importHistory = [];

  input = args.i || args.input || args._[0];

  output = args.o || args.output || args._[1];

  help = args.h || args.help;

  shouldUglify = args.u || args.uglify;

  shouldStdout = args.s || args.stdout;

  shouldPreserve = args.p || args.preserve;

  notRecursive = args.n || args.notrecursive;

  conditionsPassed = args.c || args.conditions || [];

  outputIsFile = extRegEx.test(output);

  if (help) {
    process.stdout.write(yargs.help());
    process.exit(0);
  }

  startReplacement = function(input, output, passedOptions) {
    var defaultOptions, dirContext, fileExt, inputContent, inputIsFromModule, isCoffeeFile, replacedContent;
    defaultOptions = {
      inputType: 'stream',
      outputIsFile: false,
      uglify: false,
      recursive: true,
      stdout: false,
      preserve: false,
      conditions: []
    };
    options = extend(defaultOptions, passedOptions);
    if ((output == null) && !options.stdout) {
      inputIsFromModule = true;
    }
    if (options.inputType === 'stream') {
      inputContent = input;
      dirContext = process.cwd();
    } else if (options.inputType === 'path') {
      input = path.normalize(input);
      output = path.normalize(output);
      fileExt = input.match(extRegEx)[1];
      isCoffeeFile = fileExt.toLowerCase() === 'coffee';
      inputContent = getFileContents(input, isCoffeeFile, inputIsFromModule);
      dirContext = getNormalizedDirname(input);
    }
    replacedContent = applyReplace(inputContent, dirContext, isCoffeeFile);
    if (shouldUglify) {
      replacedContent = uglify.minify(replacedContent, {
        fromString: true
      }).code;
    }
    if (inputIsFromModule) {
      return replacedContent;
    } else {
      if (options.outputIsFile) {
        return fs.writeFileSync(output, replacedContent);
      } else {
        return process.stdout.write(replacedContent);
      }
    }
  };

  applyReplace = function(input, dirContext, isCoffeeFile) {
    return output = input.replace(importRegEx, function(match, spacing, conditions, filePath) {
      var childDirContext, childIsCoffeeFile, condition, i, importedFileContent, importedHasImports, len, matchedConditions, replacedContent, resolvedPath;
      filePath = filePath.replace(/['"]/g, '');
      resolvedPath = path.normalize(dirContext + '/' + filePath);
      childIsCoffeeFile = (resolvedPath.match(extRegEx) != null) && resolvedPath.match(extRegEx)[1].toLowerCase() === 'coffee';
      importedFileContent = getFileContents(resolvedPath, isCoffeeFile);
      importedHasImports = importRegEx.test(importedFileContent);
      replacedContent = match;
      matchedConditions = true;
      if (conditions) {
        conditions = conditions.split(/,\s?/);
        for (i = 0, len = conditions.length; i < len; i++) {
          condition = conditions[i];
          if (!conditionsPassed.includes(condition)) {
            matchedConditions = false;
          }
        }
      }
      if (matchedConditions) {
        if (!importedFileContent) {
          return match;
        }
        if (!importHistory.includes(resolvedPath)) {
          importHistory.push(resolvedPath);
          if (importedHasImports) {
            childDirContext = getNormalizedDirname(resolvedPath);
            replacedContent = applyReplace(importedFileContent, childDirContext, childIsCoffeeFile);
          } else {
            replacedContent = importedFileContent;
          }
        }
        if (spacing) {
          if (spacing !== '\n') {
            spacing = spacing.replace(/^\n*/, '');
            replacedContent = replacedContent.split('\n').map(function(line) {
              return spacing + line;
            }).join('\n');
          }
          replacedContent = '\n' + replacedContent;
        }
        if (isCoffeeFile && !childIsCoffeeFile) {
          return replacedContent.replace(/^(\s*)((?:.|\n)+)/, function(entire, spacing, content) {
            if (spacing == null) {
              spacing = '';
            }
            return spacing + '`' + content + '`';
          });
        } else if (!isCoffeeFile && childIsCoffeeFile) {
          throw new Error('You\'re trying to import a coffeescript file into a JS file, I don\'t think that\'ll work out well :)');
          return process.exit(1);
        } else {
          return replacedContent;
        }
      } else {
        if (shouldPreserve) {
          return replacedContent;
        } else {
          return '';
        }
      }
    });
  };

  getFileContents = function(inputPath, isCoffeeFile, inputIsFromModule) {
    var extension, inputPathHasExt;
    if (inputIsFromModule) {
      return inputIsFromModule;
    } else {
      extension = isCoffeeFile ? '.coffee' : '.js';
      inputPathHasExt = extRegEx.test(inputPath);
      if (!inputPathHasExt) {
        inputPath = inputPath + extension;
      }
      if (checkIfInputExists(inputPath)) {
        return fs.readFileSync(inputPath).toString();
      } else {
        return false;
      }
    }
  };

  getNormalizedDirname = function(inputPath) {
    return path.normalize(path.dirname(path.resolve(inputPath)));
  };

  checkIfInputExists = function(inputPath) {
    var error, error1;
    try {
      if (fs.statSync(inputPath).isFile()) {
        return true;
      } else {
        return false;
      }
    } catch (error1) {
      error = error1;
      return false;
    }
  };


  /*==========================================================================
     Calling and Initing the script
     ==========================================================================
   */

  if (!output && (input != null)) {
    output = input.replace(extRegEx, function(entire, endOfPath) {
      return '.compiled.' + endOfPath;
    });
  } else if (!outputIsFile) {
    if (output.charAt(output.length - 1) !== '/') {
      output = output + '/';
    }
    output = output + input.replace(extRegEx, function(entire, endOfPath) {
      return '.compiled.' + endOfPath;
    });
  }

  if (input != null) {
    startReplacement(input, output, {
      inputType: 'path',
      recursive: !notRecursive,
      outputIsFile: outputIsFile,
      uglify: shouldUglify,
      shouldStdout: shouldStdout,
      conditions: conditionsPassed,
      preserve: shouldPreserve
    });
  } else {
    input = '';
    process.stdin.on('data', function(data) {
      return input += data.toString();
    });
    process.stdin.on('end', function() {
      return startReplacement(input, output, {
        inputType: 'stream',
        recursive: !notRecursive,
        uglify: shouldUglify,
        shouldStdout: shouldStdout,
        onditions: conditionsPassed,
        preserve: shouldPreserve
      });
    });
  }

  function applyIncludesPolyfill(){
	if (!Array.prototype.includes) {
		Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {
			'use strict';
			var O = Object(this),
				len = parseInt(O.length) || 0;
			if (len === 0) return false;
			
			var n = parseInt(arguments[1]) || 0,
				k;
			if (n >= 0) {
			  k = n;
			} else {
			  k = len + n;
			  if (k < 0) {k = 0;}
			}
			var currentElement;
			while (k < len) {
			  currentElement = O[k];
			  if (searchElement === currentElement ||
			     (searchElement !== searchElement && currentElement !== currentElement)) {
			    return true;
			  }
			  k++;
			}
			return false;
		};
	}
};

  module.exports = startReplacement;

}).call(this);
